\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb, amsthm}

\newtheorem{theorem}{Theorem}  
%\usepackage{unicode-math}
\usepackage{algorithm, algorithmicx}  % Para pseudocódigo
\usepackage{tikz}  % Para gráficos
\usetikzlibrary{automata, positioning}
\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{fullpage}

\usepackage{tcolorbox}
\tcbuselibrary{skins}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			COMMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\newcommand{\santiago}[1]{\todo[inline, color=green!20]{{\bf S:} #1}}
\newcommand{\cristian}[1]{\todo[inline, color=red!20]{{\bf C:} #1}}

\newcommand{\ox}{x\!\vdash}
\newcommand{\cx}{\dashv\!x}
\newcommand{\Vars}{\operatorname{Vars}}
\newcommand{\doc}{\operatorname{doc}}
\newcommand{\tup}{\operatorname{tup}}


\newtcolorbox{notabox}{
  colback=blue!5!white,
  colframe=blue!75!black,
  fonttitle=\bfseries,
  title=Nota,
  boxrule=1pt,
  arc=4pt,
  boxsep=5pt,
  left=6pt,
  right=6pt,
  top=6pt,
  bottom=6pt
}


\title{Equivalence between models for regex-based information extraction with errors}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We formalize and prove the equivalence between two models for regex-based information extraction with errors: (1) a semantics operating on the original document with error annotations, and (2) a semantics working on a modified document with edit operations. We demonstrate a bijective mapping between matches in both models, preserving spans and error operations under consistent index transformations. This results enable interoperability between systems using either approach.
\end{abstract}

\section{Preliminaries}

\subsection{Basic definitions}

\paragraph{Document and spans.} A document $d$ is a string over a finit alphabet $\Sigma$, we write $d= a_0a_2...a_{n-1}$ to denote a document of legth $|d| = n$. A span over a document $d$ is a pair $s = [i, j\rangle$ of natural numbers $i$ and $j$ with $0 \leq i \leq j \leq |d|$. $s$ is associated with a substring of $d$ from position $i$ to position $j-1$. We denote this substring by $d(s)$. Given two spans $s_1 = [i_1, j_1\rangle$ and $s_2 = [i_2, j_2\rangle$, the concatenation of $s_1$ and $s_2$ is defined as $s_1 \cdot s_2 = [i_1, j_2\rangle$, whenever $j_1 = i_2$.

\paragraph{Mappings.} Let $V$ be a fixed set of variables, disjoint from $\Sigma$. A \textit{mapping} is a function $\mu$ from a finite set of variables $dom(\mu) \subseteq V$ to spans. The empty mapping, denoted by $\varnothing$, is the only mapping such that $dom(\varnothing) = \varnothing$. Similarly, $[x \xrightarrow{} s]$ denotes the mapping whose domain only cointains the variable $x$, which it assign to span $s$.

\paragraph{Document spanners.} A document spanner is a function that map every document $d$ to a set of mappings $M$, such that the range of each $\mu \in M$ are spans of d modeling the process of extracting information from d. We will work with 3 models for defining spanners: RGX, ref-words and variable-set automata.

\cristian{Agregar definición general de que es un document spanner.}


\paragraph{Regex formulas.} A \textit{regex-formula} (\textbf{RGX} for short) is a regular expression extended with variables in $V$ (called capture variables). Formally, we define the syntax with the recursive rule:

\[e \ := \ \varnothing \mid \epsilon \mid e \mid e \lor e \mid e \cdot e \mid e^* \mid x\{ \; e \; \}\]

\cristian{Agregar la semántica de RGX.}

\paragraph{Variable-set automata.} A \textit{variable-set automaton}(VA) can be understood as an $\epsilon$-NFA that is extended with capture variables in a way analogous to RGX; that is, it behaves a usual finite state automaton with $\epsilon-$transitions, except it can also open and close variables. Formally, a VA $\mathcal{A}$ is tuple $(Q, \Sigma, V, q_0, F, \delta )$, where $\Sigma$ is a finite set of alphabet symbols, V is a finite set of variables, Q is a finite set of states, $q_0 \in Q$ is an initial state, $F \subseteq Q$ is a set of final states and $\delta$ is a transition relation consisting of letter transitions of the form $(q, a, q')$ and variable transition of the form $(q, \ox, q')$ or $(q, \cx, q')$, where $q, q' \in Q$, $a \in Q$ and $x \in V$. We define the set $\Vars(\mathcal{A})$ as the set of all variables that occur in $\mathcal{A}$.

A configuration of a VA $\mathcal{A}$ over a document $d = a_0 a_1 ... a_{n-1}$ is a tuple $(q, i)$, where $q \in Q$ is the current state and $i \leq n$ is the current position in the document. A run $\rho$ of $\mathcal{A}$ is sequence of the form: \[\rho := (q_0, i_o) \xrightarrow[]{a_0}(q_1, i_1) \xrightarrow[]{a_1} \cdots \xrightarrow[]{a_{n-1}} (q_{n-1}, i_{n-1})\]where $a_i \in \Sigma \cup \{\ox, \cx\; | \; x \in V\}$ and $(q_i, a_{i+1}, q_{i+1})$. Moreover, $i_0...i_{n-1}$ is a non-decreasing sequence such that $i_0 = 1$ and $i_{n-1} = |d|$, and $i_{j+1} = i_j + 1$ if $a_{j+1} \in \Sigma$ and $i_{n-1} = i_{j}$ otherwise. 

\cristian{Agregar la semántica de spanners.}


\paragraph{Ref-words.} For a finite set $V$ of variables, ref-words are defined over the extended alphabet $\Sigma \cup \Gamma_V$, where $\Gamma_v := \{\ox, \cx \in V\}$, we assume that $\Gamma_V$ is disjoint with $\Sigma$. Ref-words extend strings over $\Sigma$ by encoding opening $(\ox)$ and closing $(\cx)$ of variables.
A ref-words $r \in (\Sigma \cup \Gamma_V)^*$ is valid if every ocurring variable is opened and closed exactly once. For every valid ref-word r over $(\Sigma \cup \Gamma_V)$ we define $\Vars(r)$ as the set of variables $x \in V$ which ocurr in the ref-word. More formally:
\[
\Vars(r) := \{ x \in V \; | \; \exists r^{prev}_x, r_x, r_x^{post} \in (\Sigma \cup \Gamma_V)^*.\; r = r_x^{prev} \cdot x\vdash \cdot r_x \cdot \dashv x \cdot r_x^{post}\}
\]

Intuitively, each valid ref-word encondes a mapping for some document d, the variable markers encode where the spans begin and end. Formally, we define functions $\doc$ and $\tup$ that, given a valid ref-word, output the corresponding document and mapping. The morphism $\doc: (\Sigma \cup \Gamma_V)^* \xrightarrow[]{} \Sigma^*$ is defined as:
\[
\doc(a) :=
\begin{cases}
a & \text{if } a \in \Sigma \\[6pt]
\varepsilon & \text{if } a \in \Gamma_V
\end{cases}
\]
Now, we have that every valid ref-word has a unique factorization
\[
r = r_x^{prev} \cdot x\vdash \cdot r_x \cdot \dashv x \cdot r_x^{post}
\] 
for each $x \in \Vars(r)$. We can define de function $\tup$ as 
\[
\tup(r) := \{x \xrightarrow[]{} [i_x, j_x\rangle \; | \; x \in \Vars(r), i_x = |\doc(r^{prev}_x)|, j_x = i_x + |\doc(r_x)|\}
\]
The usage of the doc morphism ensures that indices $i_x$ and $j_x$  refer to positions in the document and do not consider other variable operations. 

\subsection{Edit distance}

\cristian{Agregar las operaciones de ediciones y edit distance acá.}
%
%\subsection{REmatch Semantics}
%\label{sec:rematch-semantics}
%
%REmatch's formal semantics are defined through inductive rules that specify how patterns match documents and produce variable bindings. The core semantic definition appears in Table~\ref{tab:rematch-semantics}, which we explain below.
%
%\subsubsection{Semantic Foundations}
%The semantics operates on two levels:
%\begin{itemize}
%    \item $\llbracket e \rrbracket_d$: The set of all $(span, mapping)$ pairs where $e$ matches document substring $d[span]$
%    \item  $\llbracket e \rrbracket_d$: The final variable mappings produced by matching $e$ against entire document $d$
%\end{itemize}
%
%\begin{table}[htbp]
%\centering
%\caption{Inductive semantics of REQL queries}
%\label{tab:rematch-semantics}
%\begin{tabular}{ll}
%\toprule
%\textbf{Pattern} & \textbf{Semantics} \\
%\midrule
%$a$ & $\llbracket a \rrbracket_d = \{(s, \emptyset) \mid s \in \text{span}(d) \land d(s) = a\}$ \\
%$.$ & $\llbracket . \rrbracket_d = \{([i,i+1\rangle, \emptyset) \mid 0 \leq i < |d|\}$ \\
%$[w]$ & $\llbracket [w] \rrbracket_d = \{(s, \emptyset) \mid d(s) \in \text{set}(w)\}$ \\
%$\texttt{!x}\{e\}$ & $\llbracket \texttt{!x}\{e\} \rrbracket_d = \{(s, \mu) \mid \exists (s, \mu') \in \llbracket e \rrbracket_d : \mu = \mu' \cup [x \mapsto s]\}$ \\
%$e_1e_2$ & $\llbracket e_1e_2 \rrbracket_d = \{(s_1 \cdot s_2, \mu_1 \cup \mu_2) \mid (s_i, \mu_i) \in \llbracket e_i \rrbracket_d\}$ \\
%$e_1|e_2$ & $\llbracket e_1|e_2 \rrbracket_d = \llbracket e_1 \rrbracket_d \cup \llbracket e_2 \rrbracket_d$ \\
%$e^*$ & $\llbracket e^* \rrbracket_d = \bigcup_{k\geq0} \llbracket e^k \rrbracket_d$ \\
%\bottomrule
%\end{tabular}
%\end{table}

%\subsubsection{Key Semantic Rules}
%The table shows how REmatch composes matches from subexpressions:
%
%
%This semantic model enables REmatch to:
%\begin{itemize}
%    \item Track all possible matches simultaneously
%    \item Maintain correct variable binding scopes
%    \item Compose matches algebraically via span concatenation
%\end{itemize}

\subsection{Edit Distance and Error Formalization}
\label{sec:edit-distance}

\subsubsection{The Edit Distance Problem}
In document processing with regular expressions, we often encounter texts with imperfections such as:
\begin{itemize}
    \item Typos (e.g., documment instead of document)
    \item Missing characters (e.g., docment)
    \item Extra insertions (e.g., docuument)


    ``a'' $\rightarrow$ ``abc''.  ins(1, b), ins(c,2) | ins (1,c) ins(1,b)


\end{itemize}

The \emph{edit distance} between two strings $D$ and $D'$, denoted by $\Delta(D,D')$, is the minimum number of elementary edit operations required to transform $D$ into $D'$. We consider three fundamental operations:\\

Given a document $D = a_1 \cdots a_n$:
\begin{center}
\begin{itemize}
    \item \textbf{Insertion}: $\mathsf{ins}(p,c)$ - Insert character $c$ at position $p$
    \[ D' = a_1 \cdots a_p c a_{p+1} \cdots a_n \]
    \item \textbf{Deletion}: $\mathsf{del}(p)$ - Delete character at position $p$
    \[ D' = a_1 \cdots a_{p-1} a_{p+1} \cdots a_n \]
    \item \textbf{Substitution}: $\mathsf{sub}(p,c)$ - Replace $a_p$ with $c$
    \[ D' = a_1 \cdots a_{p-1} c a_{p+1} \cdots a_n \]
\end{itemize}
\end{center}


\section{Edit Operation Application}
\label{sec:edit-application}

\subsection{Formal Definition}

Given a document $D \in \Sigma^*$ (where $D = d_1d_2\cdots d_n$) and a sequence of edit operations $E = [op_1, \ldots, op_m]$, we define the transformed document $\mathsf{apply}(D, E)$ recursively as:

\[
\mathsf{apply}(D, E) = 
\begin{cases}
D & \text{if } E = \emptyset \\
\mathsf{apply}(\mathsf{op}_1(D), [op_2, \ldots, op_m]) & \text{otherwise}
\end{cases}
\]

where each atomic operation $\mathsf{op}_i$ modifies the document as follows:

\begin{align*}
\mathsf{ins}(p,c)(D) &= d_1\cdots d_p c d_{p+1}\cdots d_n \quad (0 \leq p \leq n) \\
\mathsf{del}(p)(D) &= d_1\cdots d_{p-1} d_{p+1}\cdots d_n \quad (1 \leq p \leq n) \\
\mathsf{sub}(p,c)(D) &= d_1\cdots d_{p-1} c d_{p+1}\cdots d_n \quad (1 \leq p \leq n)
\end{align*}

\subsection{Properties}

\begin{center}
For any document $D$ and valid operation sequence $E$:
\begin{enumerate}
    \item \textbf{Termination}: $\mathsf{apply}(D, E)$ always terminates in $O(|E|)$ steps
    \item \textbf{Length Change}: $|\mathsf{apply}(D, E)| = |D| + \#\mathsf{ins} - \#\mathsf{del}$
    \item \textbf{Order Sensitivity}: $\mathsf{apply}(D, [op_1, op_2]) \neq \mathsf{apply}(D, [op_2, op_1])$ in general
\end{enumerate}
\end{center}

\subsubsection{Example}

\begin{center}
    
Let $D = \texttt{algorithm}$ and $E = [\mathsf{ins}(3,\texttt{h}), \mathsf{del}(6), \mathsf{sub}(2,\texttt{L})]$. Then:

\begin{align*}
\mathsf{apply}(D, E) &= \mathsf{apply}(\mathsf{ins}(3,\texttt{h})(\texttt{algorithm}), [\mathsf{del}(6), \mathsf{sub}(2,\texttt{L})]) \\
&= \mathsf{apply}(\texttt{alghorithm}, [\mathsf{del}(6), \mathsf{sub}(2,\texttt{L})]) \\
&= \mathsf{apply}(\texttt{alghorthm}, [\mathsf{sub}(2,\texttt{L})]) \\
&= \texttt{alLgrithm}
\end{align*}
\end{center}

\section{Models for information extraction with errors}

Now, we will consider two diferent approaches to aboard the edit distance problem in Rematch engine. 

\subsection{Error over the original document}

Normally, when we think in some computer system that correct typos, we imagine that this system say us: ``This is your document, you have to make this changes to correct it''\\

In this approach, we will work on that idea. Given a document $d \in \Sigma^*$ (where $d = d_1d_2\cdots d_n$) and a REQL expression $R$, we define the semantics of R with k error as it follows:

\[ \llbracket R \rrbracket^{\leq K}_d = \{(s, \mu, E) \; | \; s \in\mathsf{span(d)} \land \mathsf{apply}(d, E) \in \mathcal{L}(R) \land |E| \leq K \}\]


\begin{notabox}
Santiago: Para este caso, apply falla, ya que en esta semantica, como los errores se hacen sobre los spans del documento original, pueden haber varios errores en la misma posicion, lo que hace que el apply falle. Las opciones para arreglarlo son concatenar errores en una misma posicion o usar un apply que lleve un trackeo de la posicion
\end{notabox}


Here, we output a span and a mapping over the original document and the list of errors that the user have to make in de document d, to complete de match.

As we work over spans in the original document, we can have errors that apply in the same position of the document, for that reason, es crucial to mantain a correct order in the edits to get te correct match.

\subsubsection{Example}


Given the document $d = a$ and the regex $e = a!x\{b\}c$, with $k = 2$ two errors available, the following is a match in this sematics.

\[
\Big([0,1\rangle,\ \mu := \{x \mapsto [1,1\rangle\},\ E = [\mathsf{ins}(1,\texttt{b}), \mathsf{ins}(1,\texttt{c})]\Big)
\]

\subsubsection{Idea para computar}

Usar un automata de levenstein que lleve registro de las posiciones del documento donde se hicieron los errores.


\subsection{Error over a modified document}

The last approach can be confusing, as we don't use spans of the document with the changes, is not really clear how to make the edits. Moreover, is neither clear how to build the errors sequence if we work over the original document.

The other option is the straightforward version. Take a document d, compute all the possibles documents d' that the edit distance between d and d' is less than k and prove if d' matches de REQL expresion.

This is the semantics for this approach: \\

Given a document $d \in \Sigma^*$ (where $d = d_1d_2\cdots d_n$) and a REQL expression $R$, we define the semantics of R with k error as it follows:


\[ \llbracket R + k \rrbracket_d = \{(s, \mu, E) \; | \; \exists d'. \mathsf{apply}(d, E) = d' \land (s, \mu) \in \llbracket R \rrbracket_{d'} \land | E | \leq K  \}\]


We make a match in a new document d' that is the result of apply the edits in E over d. The span and the mapping is over d' because we only compute d' and treat it like the original document.

\subsubsection{Example}

Using the same example as before, with $d = a$, $e= a!x\{b\}c$ and $k = 2$ the following is a valid match in the new semantics:

\[([0, 3\rangle, \mu := [x \mapsto [1, 2\rangle], E = (ins(1, b), ins(c,2))\]

The document d' that make the  match is $d' = abc$, the span and mapping is over this document.

Now we give the user the new document and the list of edits that we make over the original to get the new one.

\subsubsection{Idea para computar}

Se puede seguir una idea similar a la que usa en el modulo de filtering, aplicar un algoritmo de light search sobre el documento original que, si es que no se llega a encontrar ningun match, pueda agregar al documento los pasos que faltaron para obtener al menos un match 

\section{Equivalence Proof}
\label{sec:equivalence}

\begin{theorem}
For any document $d$, REQL expression $R$, and error budget $k$, there exists a bijection between:
\begin{align*}
\llbracket R \rrbracket^{\leq k}_d &\leftrightarrow \llbracket R + k \rrbracket_d \\
\end{align*}

\end{theorem}

\textbf{Proof}\\

First, let's define some functions that will help us with the proof:\\

\textbf{Forward and Backwards:} Para un documento $d$, secuencia de errores $E$, we define $\mathsf{dels}_{\leq p}(E), ins_{\leq p}(E)$ as counters of the deletions and insertions edits that are made before position p \\

For example, with $ E = (subs(2, a), del(3), del(4), ins(c, 9) , ins (k ,10)$ we have $\mathsf{dels_{\leq 3}} (E) = 1, \mathsf{dels_{\leq 1}} (E)  = 0, \mathsf{ins_{\leq 10}} (E) = 2$. \\

Let $\Delta_{\leq p} (E) = \mathsf{ins}_{\leq p}(E) - \mathsf{dels}_{\leq p} (E)$. Using this, we can define the $\mathsf{forward}, \mathsf{backward}$ functions as it follows: \\

1. \textbf{For Spans}:
\[
\mathsf{forward}([i,j\rangle, E) = [i, j + \Delta_{\leq j}(E)\rangle
\]
\[
\mathsf{backward}([i',j'\rangle, E) = [i', j' - \Delta_{\leq j'}(E)\rangle
\]

2. \textbf{For Mappings}:
\[
\mathsf{forward}(\mu, E)(x) = \mathsf{forward}(\mu(x), E)
\]
\[
\mathsf{backward}(\mu', E)(x) = \mathsf{backward}(\mu'(x), E)
\]

3. \textbf{For Errors}:\\
Given $E = [op_1,...,op_m]$ in $d$, convert into $E'$ in $d'$:
\[
\mathsf{forward\_ops}(E) = [\mathsf{adjust}(op_1),...,\mathsf{adjust}(op_m)]
\]
where for $op = \mathsf{ins}(p,c), \mathsf{del}(p), \mathsf{sub}(p,c)$:
\[
\mathsf{adjust}(op_k) = 
\begin{cases}
\mathsf{ins}(p + \Delta_{\leq p}([op_1, ..., op_{k-1}]), c) \\
\mathsf{del}(p + \Delta_{\leq p}([op_1, ..., op_{k-1}])) \\
\mathsf{sub}(p + \Delta_{\leq p}([op_1, ..., op_{k-1}]), c)
\end{cases}
\]\\

Now, the inverse process, convert d' into d:

\[
\mathsf{backward\_ops}(E') = [\mathsf{adjust}^{-1}(op'_1), \dots, \mathsf{adjust}^{-1}(op'_m)]
\]

where for each operation $op' =  \mathsf{ins}(p', c), \mathsf{del}(p'), \mathsf{sub}(p', c)$:

\[
\mathsf{adjust}^{-1}(op'_k) = 
\begin{cases}
\mathsf{ins}(p' - \Delta_{\leq p'}([op'_1, ..., op'_{k-1}]), c) \\
\mathsf{del}(p' - \Delta_{\leq p'}([op'_1, ..., op'_{k-1}])) \\
\mathsf{sub}(p' - \Delta_{\leq p'}([op'_1, ..., op'_{k-1}]), c)
\end{cases}
\]\\


Finally, we can continue with the proof, now we have to prove both sides of the equivalence

\subsubsection{$\llbracket R \rrbracket^{\leq k}_d \implies \llbracket R + k \rrbracket_d$}
Given $(s, \mu, E) \in \llbracket R \rrbracket^{\leq k}_d$ we will map using the forward function:

\[(s, \mu, E) \mapsto (\mathsf{forward}(s,E), \mathsf{forward}(\mu, E), \mathsf{forward\_ops}(E))\]

\begin{enumerate}
\item By definition, $\mathsf{apply}(d,E) \in \mathcal{L}(R)$
\item Let $d' = \mathsf{apply}(d,E)$
\item Note that $s' = \mathsf{forward}(s,E)$ is span of $d'$
\item The forward mapping preserves captures moving the indices: $\mu'(x) = \mathsf{forward}(\mu(x), E)$
\item Errors are moving to match the new document, $E' = \mathsf{forward\_ops}(E)$
\item Thus $(s', \mu', E') \in \llbracket R + k \rrbracket_d$ because we know that $\mathsf{apply}(d,E) \in \mathcal{L}(R)$, so $(s', \mu') \in \llbracket R \rrbracket_d$
\end{enumerate}

\subsubsection{$\llbracket R + k \rrbracket_d \implies \llbracket R \rrbracket^{\leq k}_d$}
Given $(s', \mu', E') \in \llbracket R + k \rrbracket_d$:
\begin{enumerate}
\item we have an $d' = \mathsf{apply}(d,E)$ that meets $(s', \mu') \in \llbracket R \rrbracket_{d'}$
\item The inverse mapping recovers original positions:
\begin{align*}
s &= \mathsf{backward}(s', E) \\
\mu(x) &= \mathsf{backward}(\mu'(x), E) \\
E' &= \mathsf{backward\_ops}(E)\\
\end{align*}
\item The triple $(s, \mu, E')$ satisfies all conditions of $\llbracket R \rrbracket^{\leq k}_d$
\end{enumerate}



The equivalence requires:
\begin{itemize}
\item Identity preservation: $\mathsf{backward}(\mathsf{forward}(s,E),E) = s$
\end{itemize}




\end{document}